#lang sicp
;; exercise 3.20
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)

;; 3.3.2 Representing Queues
;; queue is a cons contains two pointers, one point to first element,
;; second points to last element.
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr! queue item)
  (set-cdr! queue item))
(define (empty-queue? queue)
  (null? (front-ptr queue)))
(define (make-queue) (cons '() '()))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "Front called with an empty queue" queue)
      (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "Delete called with an empty queue" queue))
        (else (set-front-ptr! queue (cdr (front-ptr queue)))
              queue)))
(define q1 (make-queue))
(insert-queue! q1 'a)
(insert-queue! q1 'b)

;; exercise 3.21
;; the standard Lisp printer will printer the front-ptr and rear-ptr both
;; if we insert one item in queue , we will know that both pointer point to
;; same item, so the print is verbose. we just need print the front-ptr.
(define (print-queue queue)
  (display (front-ptr queue))
  (newline))
(print-queue q1)
(delete-queue! q1)
(print-queue q1)
(delete-queue! q1)
(print-queue q1)

;; exercise 3.22
(define (make-queue2)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-queue?) (null? front-ptr)) 
    (define (insert item)
      (let ((pair (cons item '())))
      (if (empty-queue?)
          (begin (set! front-ptr pair)
                 (set! rear-ptr pair))
          (begin (set-cdr! rear-ptr pair)
                 (set! rear-ptr pair)))))
    (define (pop)
      (if (empty-queue?)
          (error "pop called with an empty queue.")
          (begin (set! front-ptr (cdr front-ptr)))))
    (define (dispatch m)
      (cond ((eq? m 'insert) insert)
            ((eq? m 'pop) (pop))
            ((eq? m 'empty?) (empty-queue?))
            ((eq? m 'front-queue) (car front-ptr))
            ((eq? m 'print) front-ptr)
            (else (error "wrong msg!" m))))
    dispatch))
(define q2 (make-queue2))
((q2 'insert) 'a)
(q2 'print) ;; -> (a)
((q2 'insert) 'c)
(q2 'print) ;; -> (a c)
(q2 'pop)
(q2 'print) ;; -> (c)
(q2 'front-queue) ;; -> c
(q2 'empty?) ;; -> #f

(define li (cons (cons '() 'a) '()))

(cdr (car li))
(car li)
(cdr li)


;; exercise 3.23   implement double-ended queue
(define (make-deque)
  (define f-p '())
  (define r-p '())
  (define (set-r-p! t)
    (set-cdr! r-p t))
    (define (empty-queue?) (null? f-p))
    (define (rear-insert item)
      (let ((triple (cons (cons r-p item) '())))
        (if (empty-queue?)
            (begin (set! f-p triple)
             (set! r-p triple)
             dispatch)
            (begin (set-r-p! triple)
                   (set! r-p triple)
                   dispatch))))
    (define (front-insert item)
      (let ((triple (cons (cons '() item) f-p)))
        (if (empty-queue?)
            (begin (set! f-p triple)
             (set! r-p triple)
             dispatch)
            (begin (set-car! (car f-p) triple)
                   (set! f-p triple)
                   dispatch))))
    (define (front-delete)
      (if (empty-queue?)
          (error "Delete called with an empty deque")
          (begin
            (set! f-p (cdr f-p))
            dispatch)))
    (define (rear-delete)
      (if (empty-queue?)
          (error "Delete called with an empty deque")
          (begin
            (set! r-p (car (car r-p)))
            (set-cdr! r-p '())
            dispatch)))

  (define (print)
    (define (iter front)
      (if (null? front)
          (display "")
          (begin (display (cdr (car front)))
                 (display " ")
                 (iter (cdr front)))))
    (begin
      (display "(")
      (iter f-p)
      (display ")")
      (newline)))
    (define (dispatch m)
      (cond ((eq? m 'f-i) front-insert)
            ((eq? m 'r-i) rear-insert)
            ((eq? m 'empty?) (empty-queue?))
            ((eq? m 'f-d) (front-delete))
            ((eq? m 'r-d) (rear-delete))
            ((eq? m 'print) (print))
            (else (error "error msg"))))
    dispatch)

(define d1 (make-deque))
(((d1 'f-i) 'a) 'print)
(((d1 'f-i) 'c) 'print)
(((d1 'r-i) 'b) 'print)
((d1 'f-d) 'print)
((d1 'r-d) 'print)
(((d1 'f-i) 'd) 'print)
((d1 'f-d) 'print)
((d1 'f-d) 'print)

